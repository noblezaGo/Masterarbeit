\chapter{Anforderungsanalyse} \label{chp:Anforderungsanalyse}

\section{Übersicht}

In diesem Kapitel soll eine Anforderungsanalyse für eine Entwicklungsumgebung für GIGABOX-Steuergeräte durchgeführt werden.
In Abbildung \ref{fig:UseCasesGIGABOX} wurde gezeigt, für welche Anwendungen GIGABOXEN eingesetzt werden. 
Die Anforderungen an die Entwicklungsumgebung wurden so gestellt, dass sie Softwareentwicklern für GIGABOX-Funktionen die Umsetzung dieser Anwendungen ermöglicht und möglichst große Unterstützung bei der Codeentwicklung bietet.

Zuerst wurden Gespräche Gespräche mit Entwicklern geführt, vorhandener Programmcode aus realisierten Projekten analysiert und selbstständig Codeentwicklung mit dem bestehenden configurAIDER betrieben um herauszufinden, welche Use-Cases eine IDE zur Entwicklung von Funktionen für GIGABOX-Steuergeräte abdecken soll. Aus dieser Analyse entstanden die in Abbildung \ref{fig:UseCases} veranschaulichten Use-Cases.

\begin{figure}[!htbp]
	\centering
		\includegraphics[width=\textwidth]{images/RequirementsUseCases.png}
	\caption{Use-Case-Diagramm funktionale Anforderungen}
	\label{fig:UseCases}
\end{figure}


Von den ermittelten Use-Cases wurden direkt die funktionalen Anforderungen abgeleitet, die im folgenden Abschnitt näher beleuchtet werden.

Auf Basis der Qualitätsmerkmale für die Anforderungsspezifikation im Standard IEEE 830-1998 werden die ermittelten funktionalen Anforderungen eingeteilt in drei Prioritärsklassen: 

\begin{itemize}
	\item Essential: Das Software-System kann nicht akzeptiert werden, wenn diese Anforderung nicht in der vereinbarten Form geliefert wird.
	\item Conditional: Diese Anforderungen erweitern das Software-System in geeigneter Form. Wenn sie fehlen, würden sie den Einsatz des Systems jedoch nicht gefährden.
	\item Optional: Diese Anforderungen sind nicht unbedingt notwendig, für die Anwender jedoch eine angenehme Erweiterung (nice to have).

\end{itemize}





Zur Ermittlung der nichtfunktionalen Anforderungen wurden bekannte Vorgehensmodelle und Normen der Softwareentwicklung herangezogen.  
Die hergeleiteten nichtfunktionalen Anforderungen sollen bei der Entwicklung beachtet werden, um eine hohe Qualität der zu entwickelenden Software sicherzustellen. Auf eine Bewertung wird verzichtet.

Quelle: \cite{SWRequirements}

\section{Ermittlung und Bewertung von funktionalen Anforderungen}

\subsection{Erstellung von Projekten mit Baumstruktur}

\emph{Beschreibung}: 

Innerhalb eines Projektes können verschiedene GIGABOX-Modelle angelegt werden. Für jedes angelegte GIGABOX-Modell können PAWN-Skripte erstellt werden mit der zum Modell passenden Dateiendung .gt**.p. Für jedes angelegte GIGABOX-Modell können Include-Files hinzugefügt werden.
Der Benutzer erhält einen strukturierten Überblick über alle seine GIGABOX-Projekte und alle für ein Projekt entwickelten Skripte. Das Öffnen eines Skriptes erfolgt komfortabel über Doppelklick auf ein Skript in der Projektstruktur. Lästiges navigieren durch die Dateistruktur des PCs beim Öffnen eines Skriptes entfällt + der Benutzer muss den Ablageort im Dateisystem nicht wissen. 

\emph{Bewertung}:

Erhöht den Benutzerkomfort signikfikant, deshalb Einstufung in Prioritätsklasse "`Conditional"'.


\subsection{Einstellung der Sprache}

\emph{Beschreibung}:

Die Sprache der Benutzeroberfläche kann angepasst werden. Es soll Deutsch und Englisch zur Verfügung stehen. 

\emph{Bewertung}:

Die Darstellung der Benutzeroberfläche in der Muttersprache des Benutzers erhöht die Usability, da es die Selbstbeschreibungsfähigkeit und Individualisierbarkeit fördert. Englisch muss auf jeden Fall zur Verfügung stehen, da es die international am weitesten verbreitete Sprache ist und auch in Deutschland von einem Großteil der Menschen verstanden wird. Die Darstellung der Benutzeroberfläche in Englisch wird deshalb in Prioritätsklasse "`Essential"' eingeteilt. 
Die Darstellung in Deutsch wird in Klasse "`Optional"' eingeteilt, da die Usability dadurch nur mäßig erhöht wird. 
Das liegt daran, dass der potenzielle Benutzerkreis des Tools Entwickler sind, denen größtenteils der Umgang mit englischen GUIs vertraut ist.

\subsection{Texteditor zur Erstellung von PAWN-Skripten}

\begin{itemize}
	\item Schreiben von PAWN-Code
	
	\emph{Beschreibung:}
	
	Es steht ein Textfeld zur Verfügung, in dem PAWN-Code editiert werden kann.
	
	\emph{Bewertung:}
	
	Klasse "`Essential"', da als Grundfunktionalität einer IDE einzustufen.
	
	\item Copy/Paste
	
	\emph{Beschreibung:}
	
	Codefragmente können kopiert und an anderer Stelle eingefügt werden. 
	
	\emph{Bewertung:}
	
	Macht die Codeentwicklung bedeutend effektiver, da dem Benutzer Tipparbeit erspart bleibt. Weiterer Vorteil ist die Fehlervermeidung durch Tippfehler. Deshalb Einstufung in Klasse "`Conditional"'. 

	\item Suchen/Ersetzen
	
	\emph{Beschreibung:} 
	
	Ein Skript kann nach Zeichenketten durchsucht werden. Die gefundenen Ergebnisse werden farblich hervorgehoben und es kann zu den Ergebnissen gesprungen werden. Alle gefundenen Ergebnisse können ersetzt werden durch eine neue Zeichenkette. 
	
	\emph{Bewertung:}
	
	Das Auffinden von Variablen und Methoden im Skript wird erheblich erleichtert. Bei Umbenennung von Variablen oder Methoden wird viel Zeit eingespart und es werden Tippfehler vermieden. Einteilung in Klasse "`Conditional"'.
	
	\item Letzte Schritte rückgängig machen
	
	\emph{Beschreibung:}
	
	Die letzten vom Benutzer vorgenommenen Anweisungen können rückgängig gemacht werden.
	
	\emph{Bewertung:}
	
	Fördert die Fehlertoleranz. Einteilung in Klasse "`Conditional"'
	
	\item Paralleles Öffnen von Skripten	
	
	\emph{Beschreibung:}
	
	Mehrere Skripte lassen sich parallel über Tabs öffnen.
	
	\emph{Bewertung:}
	
	Erhöht die Usability (effektives arbeiten). Es kann einfacher Code zwischen verschiedenen Skripten kopiert werden. Klasse "`Conditional"'
	
	
	\item Anzeige aller instanziierten Variablen im Skript
	
	\emph{Beschreibung:}
	
	Alle instanziierten Variablen werden aufgelistet. Doppelklick auf einen Variablennamen in der Liste markiert im Skript alle Verwendungen der Variable. Per Drag\&Drop kann ein Variablenname aus der Liste in das Skript eingefügt werden.
				
	\emph{Bewertung: }

	Benutzer hat alle instanziierten Variablen im Blick und kann leicht zu Verwendungsstellen im Skript navigieren. Das Einfügen per Drag\&Drop bietet eine komfortable Möglichkeit der Variablenverwendung und verhindert Fehleingaben durch Tippfehler. 
	Einteilung in Klasse "`Optional"'.
	
	\item Anzeige aller implementierten Funktionen zur Navigation im Skript
	
	\emph{Beschreibung:}
	
	Alle implementierten Funktionen werden gelistet. Doppelklick auf eine Funktion führt zu einem Sprung zur Funktionsimplementierung. Per Drag\&Drop kann ein Funktionsname in das Skript gezogen werden, ein Aufruf der Funktion wird in das Skript eingefügt. Es können alle Stellen im Skript markiert werden, an denen die gewählte Funktion aufgerufen wird.
	
\emph{Bewertung:}
	
	Benutzer hat alle implementierten Funktionen im Blick und kann leicht zu Verwendungsstellen im Skript navigieren. Komfortable Möglichkeit der Funktionsverwendung, Verhindert Fehleingaben durch Tippfehler.
	Einteilung in Klasse "`Optional"'.
	
	\item Bei der Codeentwicklung unterstützende Funktionen
	
	\emph{Beschreibung:} 
	
	Es sollen Funktionen integriert werden, die schnelleres und effektiveres Schreiben von Code ermöglichen.
	Bsp: Autovervollständigung von Variablen, Funktionen und Anweisungen bei der Tastatureingabe
	
	\emph{Bewertung: }
	
	Einteilung in Klasse "`Conditional"'.
	
	\item Routingeditor
	
	\emph{Beschreibung:}
	
	\textcolor[rgb]{1,0,0}{Beschreibung für CAN hier. Auch für LIN gibt es Dokumente, die Botschaften definieren. Die Dokumente könnten geparst werden und darauf ein PAWN-Skript generiert werden, das die Botschaften als Variablen enthält.}
	
	
	Aus einer Datenbankdatei (.dbc/.arxml) können dort definierte Bussignale geladen werden. Die Signale können in verschiedenen CAN-Botschaften enthalten sein. 	
	Aus den Bussignalen kann im Routingeditor eine eigene CAN-Busbotschaft konfiguriert werden mit einer vom Benutzer definierten ID. Dazu können die Signale innerhalb der Nutzdatenfeldes einer PDU frei angeordnet werden.   
	
	Aus der im Routing-Editor konfigurierten Botschaft kann PAWN-Code generiert werden und in die Funktion OnCanRxEvent() eines geöffneten Skriptes im Texteditor eingefügt werden.
	
	\emph{Bewertung:}
	
	Beim Programmieren der GIGABOX tritt des öfteren der Use-Case auf, dass aus Signalen, die in verschiedenen auf dem Bus ankommenden Botschaften enthalten sind, eine neue Botschaft erstellt und verschickt werden soll.
	
	Dabei werden oft Bitverschiebungen benötigt, deren Programmierung viel Zeit- und Denkaufwand bedeuten. 
	Der Routingeditor ermöglicht die grafische Konfiguration von Busbotschaften und erleichtern die Umsetzung dieser Routingaufgaben.
	Einteilung in Klasse "`Optional"'.
	
	
	
	
\end{itemize}
 
\subsection{Konfigurieren einer GIGABOX ohne PAWN-Kenntnisse}

 \emph{Beschreibung:}

	Grundlegende Funktionen einer GIGABOX sollen ohne Kenntnisse von PAWN konfiguriert werden können. 
	Dazu bietet sich die Funktionsbausteinsprache an.

\emph{Bewertung:}

Erleichtert es Kunden ohne Programmierkenntnisse, selbständig GIGABOX-Funktionalitäten zu konfigurieren. Erweitert möglicherweise den Kreis an potentiellen Käufern der GIGABOX. 
Im Vergleich zur direkten Codeentwicklung können allerdings nur eingeschränkte Funktionalitäten realisiert werden. Erfahrene Softwareentwickler werden aufgrund dieser Tatsache PAWN-Code direkt entwickeln. 
Einteilung in Klasse "`Optional"'.

\subsection{Verbundene GIGABOXEN auflisten}


		
	\emph{Beschreibung:} 
	
	Alle GIGABOXEN, die mit dem PC per USB oder Bluetooth verbunden sind, werden aufgelistet. Es werden Geräteinformationen wie z.B. Modellname, Seriennummer bereitgestellt. Der Benutzer kann aus der Liste eine GIGABOX anwählen, mit der kommuniziert werden soll.	
	
	\emph{Bewertung:}	
	
	
	Verbindung zu GIGABOX per USB herstellen wird als Grundfunktionalität eingestuft, Klasse "`Essential"'. 
	Verbindung per Bluetooth wird in Klasse "`Optional"' eingestuft.

	




\subsection{PAWN-Compiler}

	\emph{Beschreibung:}
	
	PAWN-Skripte können in Bytecode übersetzt werden. 
	Wenn Include-Files verwendet werden, soll ein Linker den Bytecode des Skriptes und des Include-Files nach dem Übersetzen zusammenfügen. 
	
	\emph{Bewertung:}
	
	Das Kompilieren ist eine Grundfunktionalität und wird deshalb in die Klasse "`Essential"' eingestuft.




\subsection{Beschreiben/Auslesen des Flash-Speichers der GIGABOX}

	\emph{Beschreibung:}
	
	Skript-Applikationen können vom PC auf den Flash-Speicher einer GIGABOX übertragen werden. Sich bereits auf dem Flash-Speicher befindliche Skripte können auf den PC geladen und angezeigt werden. Die Übertragung soll jeweils per Kabel über die USB-Schnittstelle und per Bluetooth möglich sein.
	
	
	\emph{Bewertung:}

	Die Übertragung von Skripten vom PC auf eine GIGABOX über die USB-Schnittstelle wird als Grundfunktionalität bewertet und in Klasse "`Essential"' eingeteilt. Die Übertragung von der GIGABOX auf den PC über die USB-Schnittstelle ist für den Entwickler sehr nützlich, aber nicht unbedingt notwendig und wird deshalb als Klasse "`Conditional"' eingestuft.
Bluetooth-Übertragung wird in Klasse "`Optional"' eingestuft, da es wenige Use-Cases gibt, bei denen eine Funkübertragung Vorteile gegenüber der Kabelübertragung bietet. Ein möglicher Use-Case wäre eine schwer zugängliche GIGABOX im Fahrzeug, auf die ein neues Skript aufgespielt werden soll. Eine Übertragung per Bluetooth würde einen aufwändigen Ausbau der GIGABOX aus dem Fahrzeug ersparen.	


\subsection{Kommunikation mit einer GIGABOX}

	\emph{Beschreibung:}
	
	Benutzer soll Befehle an eine GIGABOX senden können, z. B. einen Reset der GIGABOX veranlassen, den Bootloader aufrufen. Außerdem sollen Diagnose- und Geräteinformationen abgerufen werden können. Die Datenübertragung soll per Kabel über die USB-Schnittstelle und per Bluetooth möglich sein.
	
	
	\emph{Bewertung:}
	
	Das Senden von Befehlen und Abrufen von Diagnose- und Geräteinformationen per Kabel über die USB-Schnittstelle wird in Klasse "`Essential"' eingestuft. Die Datenübertragung per Bluetooth wird in Klasse "`Optional"' eingestuft, da es wenige Use-Cases gibt, bei denen eine Funkübertragung Vorteile gegenüber der Kabelübertragung bietet. Ein möglicher Use-Case wäre eine schwer zugängliche GIGABOX im Fahrzeug, auf die ein neues Skript aufgespielt werden soll. Eine Übertragung per Bluetooth würde einen aufwändigen Ausbau der GIGABOX aus dem Fahrzeug ersparen.


\subsection{Kommunikation mit dem Benutzer}

	\emph{Beschreibung:}
	
	Benutzer soll Befehle über die Konsole an die IDE senden können, z. B. das Kompilieren eines Skriptes veranlassen.
	Außerdem sollen Diagnose- und Programminformationen der IDE abgerufen werden können.
	
	
	\emph{Bewertung:}

	Einstufung in Klasse "`Essential"'.


\subsection{Steuern und Beobachten von Ein-/Ausgängen und Timern}


	\emph{Beschreibung:}
	
	Die Zustände der digitalen und analogen Ausgänge sowie der internen Timer sollen über die Oberfläche der Entwicklungsumgebung gesteuert und beobachtet werden können. 
	Die Zustände der digitalen und analogen Eingänge sollen über die Oberläche der Entwicklungsumgebung beobachtet werden können. 
	Außerdem sollen vom Benutzer konfigurierte CAN- und LIN-Botschaften über die IDE gesendet werden können. Dabei soll einmaliges und zyklisches Senden von Botschaften möglich sein. 
	Auf dem Bus liegende Botschaften einer definierten ID (CAN) bzw. für eine definierte Adresse (LIN) sollen beobachtet werden können.
	
	Zusätzlich soll die Möglichkeit bestehen, Buskommunikation innerhalb eines definierten Zeitfensters mitzuloggen. Alle Busbotschaften, die innerhalb dieses Zeitfensters auf dem Bus liegen, sollen dabei mit Zeitstempel gelistet werden. 

	\emph{Bewertung:}
	
Die beschriebenen Funktionen sind für den Nutzer hilfreich bei der Codeentwicklung, aber nicht unbedingt notwendig. 
Damit können die Funktionen in die Prioritätsklasse "`Optional"' eingeteilt werden.


\subsection{Debugging}


	\emph{Beschreibung:}
	
Es sollen Breakpoints gesetzt werden können. Wenn ein Breakpoint erreicht wird, wird die Codeausführung auf der virtuellen Maschine der GIGABOX angehalten. Da der Codeausführung eventbasiert ist, werden die gesetzten Breakpoints nur erreicht, wenn das Event ausgelöst wird, in dem sich der Breakpoint befindet. Events, die auslösen während die Codeausführung angehalten ist, müssen  ignoriert werden. -> führt zu Problemen, da Timer ablaufen aber nicht neu aufgezogen werden -> Timerevents müssten trotzdem im Hintergrund auslösen und neu aufgezogen werden.
Aber Anweisungen in den Event außer TimerSet() werden ignoriert.

 CAN und LIN-Events werden ignoriert.

Der Benutzer kann zeilenweise zu den folgenden Anweisungen springen. 

	\emph{Bewertung:}
	
	Die beschriebenen Funktionen sind für den Nutzer hilfreich bei der Codeentwicklung, aber nicht unbedingt notwendig. 
Damit können die Funktionen in die Prioritätsklasse "`Optional"' eingeteilt werden.
	

\subsection{Bereitstellung von Dokumentationen}

	\emph{Beschreibung:}
	
	Die IDE soll Hilfedokumentation zu den GIGABOX-Modellen, zum configurAIDER und zu PAWN bereitstellen.
	
	
	\emph{Bewertung:}
	
	Ein direkter Zugriff von der IDE aus auf die Hilfedokumentation erhöht die Usability.
	Dies bietet dem Benutzer den Vorteil, dass er die Oberfläche der IDE nicht verlassen muss um Dokumentationen 
	aufzurufen.	
  Einteilung in Klasse "`Conditional"'.



\subsection{Individualisierbare Oberfläche}

	\emph{Beschreibung:}
	
	Die Fenster innerhalb der IDE sind frei andockbar. Somit kann der Benutzer die Oberfläche individuell nach seinen Wünschen aufbauen.
	
	\emph{Bewertung:}

	Steigert die Usability (Individualisierbarkeit), ist aber keine unbedingt notwendige Funktion und wird deshalb als "`Optional"' eingestuft.


\section{Ermittlung von nichtfunktionalen Anforderungen}

\begin{itemize}
	\item Entwicklung des Tools mit WPF unter Verwendung MVVM-Pattern
	\item Entwicklung für Windows 32bit + 64bit  als Zielbetriebssystem
	\item Entwicklung nach V-Modell
	\item Qualitätskriterien an Software nach ISO 9126 (aus Wiki)/ siehe auch Kapitel 6 Moderne Softwarearchitektur



	\begin{itemize}
		\item Wartbarkeit
		\begin{itemize} 
			\item Analysierbarkeit:
			
			Coding-Richtlinien sollen eingehalten werden: Verständliche Kommentare, einheitliche Namensgebung etc
			\item Modifizierbarkeit:
			
			SOLID-Prinzipien einhalten, um möglichst wenig Abhängigkeiten unter den Klassen zu erreichen. Dadurch treten bei Modifikationen innerhalb einer Klasse weniger schwer vorhersehbare Fehler auf 
			
			\item Testbarkeit:
			
			\textcolor[rgb]{1,0,0}{Keine Ahnung auf was bei der Entwicklung geachtet werden soll um gute Testbarkeit zu erreichen}
		\end{itemize}
			
		\item Benutzbarkeit (genauer definiert in Norm EN ISO 9241-110)
		
		\item Effizienz
			
			\begin{itemize}
				\item Akzeptable Zeit bis Tool gestartet ist und verwendbar ist
				\item Unmittelbare und flüssige Reaktion auf Benutzereingaben
			\end{itemize}
		
		\item Übertragbarkeit
			
			\begin{itemize}
				\item Anpassbarkeit: Möglichkeit, Software an verschiedene Umgebungen anzupassen
				
				Verschiedene Betriebssysteme? 32/64Bit?
			\end{itemize}
		
		\item Zuverlässigkeit
		
		\begin{itemize}
			\item Reife: Geringe Versagenshäufigkeit durch Fehlerzustände:
				Ausreichendes Testing
			\item Wiederherstellbarkeit: Fähigkeit, bei einem Versagen das Leistungsniveau wiederherzustellen und die direkt betroffenen Daten wiederzugewinnen. Zu berücksichtigen sind die dafür benötigte Zeit und der benötigte Aufwand.
		\end{itemize}

		
	\end{itemize}

\end{itemize}





























