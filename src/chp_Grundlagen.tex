\chapter{Grundlagen} 



\section{GIGABOX-Steuergeräte}

\subsection{Überblick}
GIGABOX ist eine Produktfamilie von Steuergeräten der Firma GIGATRONIK. GIGABOX-Steuergeräte werden in der Fahrzeugentwicklung eingesetzt, um prototypische Kommunikationslösungen im Fahrzeug schnell und kostengünstig realisieren zu können. Beispielanwendungen sind der Einsatz als Gateway und die Ansteuerung von Treiber-ICs im Automobil. 

GIGABOX-Steuergeräte werden in unterschiedlicher Hardwareausstattung und Funktionalität angeboten. Typischerweise verfügen sie über diverse Kommunikationsschnittstellen, die im Automotive-Bereich eingesetzt werden wie CAN und LIN. Außerdem stehen digitale und analoge Eingänge sowie digitale Ausgänge zur Verfügung. 

Das neueste Modell der GIGABOX, die GIGABOX FD, befindet sich aktuell noch in der Entwicklung. Im Vergleich zu älteren Modellen ermöglicht sie neue Funktionen wie Kommunikation über CAN FD oder Bluetooth.

\subsection{Einsatzszenarien}

Das Use-Case-Diagramm in Abbildung \ref{fig:UseCasesGIGABOX} zeigt drei typische Einsatzszenarien einer GIGABOX. 


\begin{enumerate}
	\item \textbf{Einsatz als Gateway zur Modifikation von Busbotschaften}

	Beispiel:

Ein Fahrzeughersteller entwickelt das Nachfolgemodell einer PKW-Modellreihe. 
Für das neue Fahrzeugmodell wurde eine neue Klimaanlage entwickelt, deren Funktionsfähigkeit im realen neuen Modell überprüft werden soll.
Einige Busbotschaften, die die Steuergeräte untereinander austauschen, wurden für das neue Modell verändert oder wurden neu hinzugefügt. Der Großteil der Busbotschaften sind allerdings identisch wie beim alten Modell.  \\
Das neue Modell ist allerdings noch nicht so weit entwickelt, dass es eine sinnvolle Testumgebung darstellen kann. Die neue Klimaanlage wird deshalb im alten Fahrzeugmodell getestet. Die für das Klimasteuergerät relevanten Busbotschaften können dann mithilfe einer GIGABOX so manipuliert werden, dass sie den Botschaften entsprechen, die im neuen Fahrzeugmodell am Klimasteuergerät ankommen würden.

 

	\item \textbf{Funktionalität des Fahrzeugs erweitern}

\begin{itemize}
	\item Rapid Prototyping: Eine neue Funktionalität soll möglichst schnell und unkompliziert gestestet werden
	
	Beispiel: 
	
	Ein Fahrzeughersteller möchte eine neue Idee ausprobieren.
	Die LEDs des Fahrzeugblinkers sollen dabei nicht mehr gleichzeitig aufleuchten, sondern nacheinander von innen nach außen mit kurzer zeitlicher Verzögerung.
	Zur Umsetzung dieser Idee kann eine GIGABOX verwendet werden. Registriert die GIGABOX eine Botschaft auf dem CAN-Bus, die eine Anweisung zum Blinken enthält, können die einzelnen LEDs des Blinkers zeitlich verzögert in der gewünschten Reihenfolge über die digitalen Ausgänge aktiviert werden. 
	
	\item Serieneinsatz: Eine neue zusätzliche Funktion soll realisiert werden bei Fahrzeugumbau
	
	Beispiel:
	
	Ein PKW soll zu einem Leichenwagen umgebaut werden, der elektrisch verstellbare Fensterjalousien besitzen soll. 
	Über einen Schalter soll die Höhe der Jalousien eingestellt werden können.
	Dazu wird ein Steuergerät benötigt, das die Stellung der Schalter einliest und die zur Höhenverstellung zuständigen Motoren ansteuert.
	Eine GIGABOX kann diese Aufgaben übernehmen, da sie über die benötigten digitalen Ein- und Ausgänge verfügt.
	

	
\end{itemize}
 
\item \textbf{Restbussimulation} 

Eine GIGABOX kann Steuergeräte innerhalb eines Bussystems simulieren.
Steuergeräte können damit getestet werden, ohne das komplette Bussystem aufbauen zu müssen.

Restbussimulationen können auch mit PC-Tools wie zum Beispiel "`CANoe"' von Vector Informatik GmbH und passendem Bus-Interface durchgeführt werden. Die Kosten für Softwarelizenzen und benötigter Hardware übersteigen allerdings die Kosten einer konfigurierten GIGABOX und bedingen einen komplizierteren Systemaufbau.

Quelle: http://www.samtec.de/hauptmenu/loesungen-fuer/restbussimulation.html



\end{enumerate}


\begin{figure}[!htbp]
	\centering
		\includegraphics[width=\textwidth]{images/UseCasesGigabox.png}
	\caption{Use-Case-Diagramm GIGABOX}
	\label{fig:UseCasesGIGABOX}
\end{figure}



\subsection{Hardware der GIGABOX FD}

Die GIGABOX FD ist modular aufgebaut bestehend aus einer Basisplatine und diversen Applikationsplatinen, mit denen zusätzliche Funktionalitäten zur Verfügung gestellt werden können.  
Auf der Basisplatine befindet sich ein Spannungsregler, ein 32-bit Mikrocontroller ARM Cortex M4 STM32F427IIT6, Kommunikationsschnittstellen sowie analoge und digitale Ein- und Ausgänge.  
Der Spannungsregler wird eingesetzt, um die Batteriespannung des Fahrzeugs auf die Versorgungsspannung des Mikrocontrollers herunterzuregeln.

Der Mikrocontroller wird mit einer Taktfrequenz von 168MHz betrieben und stellt 2MB Flash Speicher sowie 192 kB SRAM + 64 kB core coupled memory (CCM) zur Verfügung.

 

%Der Mikrocontroller besitzt folgende Features:

%\begin{itemize}
	%\item 2MB Flash Speicher und 192 kB SRAM (in Datenblatt 256+4kB including 64kB of CCM(core coupled memory))
	%\item Die Taktfrequenz beträgt bis zu 180MHz (shruti 168Mhz)
	%\item Drei 12-Bit A/D-Wandler sowie zwei 12-Bit D/A-Wandler
	%\item 168 I/O Ports mit Interruptfähigkeit
	%\item Kommunikationsschnittstellen:
	%
	%\begin{itemize}
		%\item 3 IQuadratC Schnittstellen
		%\item 4 USART sowie 4 UART
		%\item 6 SPI
		%\item 1 SAI
		%\item 2 CAN
		%\item 1 SDIO
	%\end{itemize}
%\end{itemize}


 
Auf der GIGABOX FD sind als Kommunikationsschnittstellen 2 CAN-, 2 CAN FD- und 2 LIN-Kanäle implementiert. Zusätzlich wird eine USB-Schnittstelle bereitgestellt, die mit einem UART-to-USB-Converter realisiert wird.
Es sind 4 analoge Eingänge vorhanden um Sensorwerte einzulesen wie z. B. von einem Temperatursensor. Mit den 8 digitalen Eingängen können z. B. Schalterzustände eingelesen werden. Als Ausgänge stehen 8 Halbbrückenausgänge und 2 Highsideausgänge zur Verfügung (Wann werden Halbbrücken- wann Highside benutzt?).  

Einen Überblick über die eingesetzte Hardware bietet Abbildung \ref{fig:HardwareGIGABOXFD} (Von Shruti, Abb neu erstellen wegen schlechter Bildqualität).

Der Einsatz von einer Applikationsplatine ermöglicht die Funktionserweiterung der GIGABOX FD um beispielsweise zusätzliche Kommunikationsschnittstellen wie Bluetooth bereitzustellen.

\begin{figure}[!htbp]
	\centering
		\includegraphics[width=\textwidth]{images/HardwareOverviewGIGABOXFD.png}
	\caption{Hardwareüberblick GIGABOX FD}
	\label{fig:HardwareGIGABOXFD}
\end{figure}


\subsection{Softwarearchitektur der GIGABOX FD}

Abbildung \ref{fig:Softwarearchitektur} gibt einen Überblick über die Softwarearchitektur der GIGABOX FD. 

Der Hardware Abstraction Layer (HAL) ist eine Softwareschicht, die übergeordnete Schichten von der Hardware abstrahiert. Übergeordnete Schichten sind damit unabhängig von der eingesetzten Hardware. Dies bietet den Vorteil, dass bei Hardwareänderungen nur der HAL angepasst werden muss, nicht aber die übergeordneten Schichten. Auf dem HAL sind die Treiber des Mikrocontrollers und der zugehörigen Peripherie implementiert. Die Treiber stellen ein Application Programming Interface (API) bereit, die Zugriff auf den Speicher oder die Peripherie des Mikrocontrollers wie z.B. Analog-Digital-Converter (ADC) ermöglicht.

Vom Middleware Layer aus kann über die API des Hardware Abstraction Layers auf die Hardware zugegriffen werden. Auf dieser Schicht ist ein USB-HID Treiber implementiert, der benötigt wird, damit die GIGABOX FD bei Verbindung mit einem Computer über USB als Human Interface Device (HID) erkannt wird. 
Außerdem befindet sich dort das Transportprotokoll ISO-TP für CAN-Bus. Das Protokoll wird benötigt, um Botschaften zu verschicken, die die maximale Nutzdatengröße von 8 Byte eines CAN-Frames überschreiten.
Um die Pawn virtuelle Maschine (VM) an den HAL anzubinden, befindet sich auf dem Middleware Layer zusätzlich die PAWN Driver Abstraction.

Auf dem Application Layer ist die Pawn VM und der Bootloader implementiert. Eine Abstraktionsebene über der Pawn VM liegt die Skript Applikation, die vom Endanwender auf den Flash-Speicher der GIGABOX FD aufgespielt werden kann. Das Skript ermöglicht die Ansteuerung bzw. Abfrage der Kommunikationsschnittstellen sowie das Steuern bzw. Beobachten der digitalen/analogen Ein-/Ausgänge der GIGABOX FD. Auf dieser Ebene ist außerdem die Konsole angesiedelt, an die der Anwender Befehle senden kann über USB.




\begin{figure}[!htbp]
	\centering
		\includegraphics[width=\textwidth]{images/GIGABOXFD_SWArchitektur.png}
	\caption{Softwarearchitektur der GIGABOX FD}
	\label{fig:Softwarearchitektur}
\end{figure}


\section{Pawn}

Pawn ist eine Skriptsprache mit einer C ähnlichen Syntax sowie eine zugehörige virtuelle Maschine, auf der kompilierter Pawn-Quellcode ausgeführt werden kann. Das Pawn-Paket, das Kompiler und virtuelle Maschine beinhaltet, ist kostenlos verfügbar und wurde unter der Apache Lizenz 2.0 veröffentlicht. Die Sprache wurde abgeleitet von der Sprache "`Small-C"', die wiederum eine Teilmenge von C darstellt und für Mikrocontroller entwickelt wurde.
Pawn wurde erstmal 1998 öffentlich zugänglich gemacht, damals noch unter dem Namen "`SMALL"' und wird seitdem regelmäßig weiterentwickelt.

Pawn-Quellcode kann mithilfe des Pawn-Kompilers in Bytecode kompiliert werden. Der Bytecode wird anschließend auf der zugehörigen virtuellen Maschine interpretiert. Dies bedeutet, dass für jede Bytecode-Anweisung definierte Funktionen aus einer C-Klassenbibliothek aufgerufen werden. Die Ausführung von Bytecode auf einer virtuellen Maschine bietet im Vergleich zur Ausführung von nativem Code auf der Zielhardware den Vorteil, dass der Code unabhängig von der eingesetzten Hardware lauffähig ist. Der Code kann folglich plattformunabhängig eingesetzt werden. Die virtuelle Maschine muss dagegen an die eingesetzte Plattform angepasst werden.
Dieser Vorteil wird allerdings mit Geschwindigkeitseinbußen bei der Programmausführung bezahlt.
Bei der Entwicklung von Pawn wurde besonders auf eine einfache Syntax, Schnelligkeit in der Codeausführung und Robustheit wert gelegt. 
Die virtuelle Maschine eignet sich aus diesem Grund auch zur Einbindung in Mikrocontroller mit geringer Rechenleistung und Speicherkapazität.

In Bezug auf GIGABOX-Steuergeräte wird Pawn benutzt, um GIGABOX-Applikationen zu erstellen. Mithilfe von GIGABOX-Applikationen kann der Anwender Funktionen für GIGABOX-Steuergeräte entwickeln und die Applikation anschließend auf GIGABOX-Steuergeräte flashen, auf denen eine Pawn-VM implementiert ist. 
GIGABOX-Applikationen werden mithilfe eventgetriebener Programmierung entwickelt. Sobald ein definiertes Event wie z. B. der Empfang einer CAN-Botschaft eintritt, wird die dem Event zugeordnete Funktion aufgerufen.
 

\cite{PawnImplementersGuide}, \cite{PawnLanguageGuide}

Siehe Pawn\_Language\_Guide.pdf, Foreword \\
Pawn\_Implementation\_Guide.pdf, The Compiler, The abstract machine


%
%\subsection{configurAIDER}
%
%Der configurAIDER ist eine von GIGATRONIK entwickelte integrierte Entwicklungsumgebung (IDE), die es Benutzern ermöglicht, mit einer GIGABOX zu kommunizieren und diese zu programmieren. Es können Diagnoseinformationen abgerufen werden und Bytecode auf das Steuergerät geflasht werden. Die IDE besteht aus Editoren (skriptEDITOR und multiEDITOR), Interpreter und Linker. Der scriptEDITOR ist ein Texteditor, mit dem PAWN-Skripte geschrieben werden können. Mit dem multiEDITOR können tabellarisch WENN DANN Anweisungen konfiguriert werden, aus denen ein Skript mit PAWN-Code generiert werden kann. Der multiEDITOR stellt für Benutzer ohne Programmierkenntnisse eine Möglichkeit dar, die GIGABOX mit rudimentären Funktionen zu konfigurieren. 
%Der integrierte Interpreter kann Bytecode aus den erstellten PAWN-Skripten erstellen und auf die GIGABOXEN flashen.

\section{Softwareentwicklungsprozess}
\subsection{V-Modell 97}

Das V-Modell 97 ist ein Vorgehensmodell für IT-Entwicklungsprojekte, das 1997 von der Bundesrepublik Deutschland veröffentlicht wurde. Es hat sich als Entwicklungsstandard in der Softwareentwicklung etabliert. 

Der Entwicklungsprozess nach dem V-Modell durchläuft verschiedene Phasen. Es beginnt mit einer Anforderungsanalyse (Phase Requirements), bei der die Anforderungen an ein System ermittelt und dokumentiert werden. Anschließend wird das System entworfen



\begin{figure}[!htbp]
	\centering
		\includegraphics[width=0.8\textwidth]{images/V-Modell-Steps.png}
	\caption{Vorgehensschritt im V-Modell}
	\label{fig:V-Modell}
\end{figure}

\subsection{Qualitätskriterien an Software} \label{sec:QualitätskriterienSW}

Um Softwarequalität definierbar zu machen, wurden diverse Software-Qualitätsmodelle entwickelt. Die ISO/IEC 25010 definiert unter anderem das Product Quality Model. 
Dieses Modell definiert acht Qualitätmerkmale für Software, die im folgenden erläutert werden:

\begin{itemize}
	\item \emph{Functional Suitability:} 
	
	"`Das Qualitätsmerkmal der funktionallen Eignung fordert, dass ein Software-System die von ihm erwartete Funktionalität in angemesserner und konkreter Art und Weise und unter Berücksichtigung der festgelegten Randbedingungen und Eigenschaften umsetzt. Dabei geht es um Fragestellungen nach der Angemessenheit der Funktionalitäten für den vorgegebenen Einsatzbereich des Systems."' \cite{SWRequirements}
	
	\item \emph{Performance Efficiency}
	
	"`Das Merkmal der Performanz und Effizienz betrachtet das Leistungsniveau einer Anwendung in Abhängigkeit der eingesetzten Betriebsmittel und der geforderten Bedingungen. Dabei geht es insbesondere um das Zeitverhalten der Anwendung (Anwendungszeit, Durchsatz) sowie das Verbrauchsverhalten in Bezug auf Speicher, Prozessorzeit und andere Ressourcen."' \cite{SWRequirements}
	
	\item \emph{Compatibility}
	
	"`Das Merkmal der Kompatibilität betrachtet einerseits die explizite Zusammenarbeit des Systems mit anderen Systemen und andererseits die impliziten Auswirkungen des Systems auf andere Systeme, die auf der gleichen Hardware laufen."' \cite{SWRequirements}
	
	\item \emph{Usability}
	
	"`Das Qualitätsmerkmal der Benutzerfreundlichkeit beschäftigt sich damit, wie gut ein System seine Nutzer dabei unterstützt ihre Ziele effizient und effektiv zu erreichen. Zu den zentralen Teilmerkmalen zählt hier beispielsweise der Aufwand für die Erlernung des Systems sowie für die Bedienung. Ein weiteres Teilmerkmal ist die Attraktivität des Systems für die Nutzer."' \cite{SWRequirements}
	
	\item \emph{Reliability}
	
	"`Das Qualitätsmerkmal der Zuverlässigkeit beschreibt die Fähigkeit des Systems sein Leistungsniveau unter festgelegten Bedingungen über einen festgelegten Zeitraum zu bewahren. Zu den Teilmerkmalen zählen hier beispielsweise die Robustheit gegenüber fehlerhaften Eingaben, die Stabilität beim Umgang mit fehlerhaften Systemzuständen und die Wiederherstellbarkeit bei Systemausfällen."' \cite{SWRequirements}
	
	
	\item \emph{Security}
	
	"`Das Merkmal umfasst alle in Bezug auf Datensicherheit relevanten Teilmerkmale wie die Datenintegrität, Authentizität und Vertraulichkeit."' \cite{SWRequirements}
	
	\item \emph{Maintainability}
	
	"`Das Merkmal der Wartbarkeit, teilweise auch als Änderbarkeit bezeichnet, beschäftigt sich vorrangig mit der internen Qualität eines Systems. Zentrale Teilmerkmale hier sind der Aufwand zur Analyse eines Fehlers oder Fehlverhaltens, der Aufwand zur Durchführung von Modifikationen mit entsprechender Testbarkeit sowie die Stabilität des Systems gegenüber unerwarteten Seiteneffekten."' \cite{SWRequirements}
	
	\item \emph{Portability}
	
	"`Die Portabilität als weiteres Qualitätsmerkmal beschäftigt sich mit dem Aufwand, um ein System strukturell zu verändern, auf eine andere Umgebung zu verlagern oder einzelne Systemkomponenten auszutauschen. Als Teilmerkmale nennt der Standard die Anpassbarkeit eines Systems an unterschiedliche Umgebungen, den Aufwand zur Installation und die Austauschbarkeit von Komponenten."' \cite{SWRequirements}
	
\end{itemize}
 



Abbildung \ref{fig:ProductQualityModel} zeigt eine Übersicht über die acht Qualitätsmerkmale und löst jedes Merkmal feingranular weiter auf.


\begin{figure}[!htbp]
	\centering
		\includegraphics[width=\textwidth]{images/ProductQualityModel.png}
	\caption{Qualitätsmerkmale des Product Quality Model nach ISO/IEC 25010}
	\label{fig:ProductQualityModel}
\end{figure}


Um das Qualitätsmerkmal "`Usability"' zu verfeinern, kann die Norm EN ISO 9241-110 (Grundsätze der Dialoggestaltung) herangezogen werden.
Diese beschreibt, welche Eigenschaften Dialoge erfüllen sollen, um eine gute Usability zu erreichen. Die sieben Grundsätze der Dialoggestaltung werden im Folgenden nach Quelle \cite{MCInteraktion}, Kapitel 8.3 zitiert.



	
\begin{itemize}
		\item Aufgabenangemessenheit: "`Ein interaktives System ist \textit{aufgabenangemessen}, wenn es den Benutzer unterstützt, seine Arbeitsaufgabe zu erledigen, d.h. wenn Funktionalität und Dialog auf den charakteristischen Eigenschaften der Arbeitsaufgabe basieren, anstatt auf der zur Aufgabenerledigung eingesetzten Technologie."'
		
		\item Selbstbeschreibungsfähigkeit: "`Ein Dialog ist in dem Maße \textit{selbstbeschreibungsfähig}, in dem für den Benutzer zu jeder Zeit offensichtlich ist, in welchem Dialog, an welcher Stelle er sich befindet, welche Handlungen unternommen werden können und wie diese ausgeführt werden können."'
		
		\item Lernförderlichkeit: "`Ein Dialog ist \textit{lernförderlich}, wenn er den Benutzer beim Erlernen der Nutzung des interaktiven Systems unterstützt und anleitet."'
		
		\item Steuerbarkeit: "`Ein Dialog ist \textit{steuerbar}, wenn der Benutzer in der Lage ist, den Dialogablauf zu starten sowie seine Richtung und Geschwindigkeit zu beeinflussen, bis das Ziel erreicht ist."'
		
		\item Erwartungskonformität: "`Ein Dialog ist \textit{erwartungskonform}, wenn er den aus dem Nutzungskontext heraus vorhersehbaren Benutzerbelangen sowie allgemein anerkannten Konventionen entspricht."'
		
		\item Individualisierbarkeit: "`Ein Dialog ist \textit{individualisierbar}, ween Benutzer die Mensch-System-Interaktion und die Darstellung von Informationen ändern können, um diese an ihre individuellen Fähigkeiten und Bedürfnisse anzupassen.
		
		\item Fehlertolerant:  "`Ein Dialog ist \textit{fehlertolerant}, wenn das beabsichtigte Arbeitsergebnis trotz erkennbar fehlerhafter Eingaben entweder mit keinem oder mit minimalem Korrekturaufwand durch den Benutzer erreicht werden kann."'


	Quelle: Wikipedia -> überprüfen ob andere Quelle verfügbar ist, am Besten die Norm direkt
	Als Quelle kann Paper von PH Weingarten "`Usability und Usability Engineering genommen werden"'. Hieraus die Stichpunkte noch verfeinern

\end{itemize}

\section{Entwicklungsframework}

\subsection{.NET Framework}

Es wurden im folgenden Abschnitt die Quellen \cite{Louis:CSharp},\cite{msdn} verwendet.

Das .NET Framework ist eine von Microsoft entwickelte Entwicklungsplattform für Anwendersoftware, die erstmals im Januar 2002 in der Version 1.0 erhältlich war. Es stellt die Umsetzung des Common Language Infrastructure (CLI) Standards dar, der sprach- und plattformunabhängige Anwendungsentwicklung spezifiziert.
Wesentliche Bestandteile des .NET Frameworks sind die Laufzeitumgebung Common Language Runtime (CLR) und die Framework Class Library (FCL). 
Die CLR verwaltet Speicher, Thread- und Codeausführung, Überprüfung der Codesicherheit und Kompilierung. Von der CLR verwalteter Code wird dabei Managed Code genannt, außerhalb der CLR laufender Code Unmanaged Code. Es wird eine Vielzahl von Programmiersprachen unterstützt, unter anderem C\#, C++ und Visual Basic .NET. Beim Kompilieren der verschiedenen Hochsprachen wird der Code zunächst in eine Zwischensprache übersetzt, der Common Intermediate Language (CIL). Aus dem daraus entstehenden Intermediate Language Code (IL-Code) wird dann von einem Just-In-Time-Compiler (JIT-Compiler) zur Laufzeit Maschinencode erzeugt (Abbildung \ref{fig:NET-Framework}).

\begin{figure}[!htbp]
	\centering
		\includegraphics[width=0.8\textwidth]{images/NET-Framework.jpg}
	\caption{Managed Code und Unmanaged Code}
	\label{fig:NET-Framework}
\end{figure}

Die FCL ist eine objektorientierte Klassenbibliothek mit einer Auflistung wiederverwendbarer Typen, von denen eigener Code abgeleitet werden kann.  


\subsection{Windows Presentation Framework (WPF)}

Mit Einführung des .NET Frameworks 3.0 im Jahr 2006 wurde Windows Presentation Foundation (WPF) veröffentlicht, ein Framework zur Erstellung von grafischen Benutzeroberflächen. WPF stellt den Nachfolger für das seit Version 1.0 im .NET Framework enthaltene Windows Forms. Es können Desktop- sowie Webanwendungen erstellt werden. 

WPF nutzt die Leistungsressourcen von Grafikkarten mit 3D-Beschleunigern besser aus als Windows Forms, da zum Rendern der GUI-Inhalte DirectX benutzt wird anstatt Graphics Device Interface+ (GDI+). Mithilfe von DirectX kann WPF grafische Elemente selbst zeichnen anstatt dass sie durch das Betriebssystem gezeichnet werden.  
Ein weiterer Vorteil von WPF ist das vektorbasierte Zeichnen der Anwendungsinhalte. Dies ermöglicht eine beliebige Skalierung der Inhalte ohne Verpixelung.

Eines der zentralen Konzepte von WPF ist die Verwendung der XML-basierten Beschreibungssprache Extensible Application Markup Language (XAML) zur Beschreibung der Benutzeroberfläche. XAML ermöglicht eine übersichtlichere und kompaktere Beschreibung der Benutzeroberfläche als die Programmierung der Oberfläche in C\#. 

Die Beschreibung einer Benutzeroberfläche mit XAML wird in einer XAML-Datei vorgenommen. 
Jede XAML-Datei ist untrennbar mit einer Codebehind-Datei gekoppelt, in der die Logik der Benutzeroberfläche in C\# programmiert werden kann.
Die Logik kann allerdings auch in einer eigenen C\#-Quellcodedatei programmiert werden und über sogenannte DataBindings und Commands an die XAML-Datei angebunden werden.
Darstellung und Logik können auf diese Weisen getrennt werden, was unter anderem eine effektivere Zusammenarbeit zwischen Designern der Benutzeroberfläche und Entwicklern der Anwendungslogik ermöglicht. 

Ein Designer kann mithilfe eines Design-Tools wie z. B. Microsoft Expression Blend die Benutzeroberfläche entwerfen und daraus eine XAML-Datei generieren. 
Der Entwickler der Anwendungslogik kann anschließend auf Grundlage der XAML-Datei des Designers die gewünschte Logik zu der GUI entwickeln.

 


