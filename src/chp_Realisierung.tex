\chapter{Realisierung}

\section{Überblick}

In diesem Kapitel wird vorgestellt, wie das in Abschnitt \ref{sec:Neuentwicklung} vorgestellte Konzept, den configurAIDER vollständig neu zu entwickeln, umgesetzt wurde. Innerhalb des V-Modells beschreibt dieses Kapitel die Implementierungsphase. 
In dieser Phase werden die in der Anforderungsanalyse festgelegten Anforderungen in Code umgesetzt unter Beachtung der in der vorherigen Phase entworfenen Softwarearchitektur.

In Abschnitt \ref{sec:Abstraktionsebene1} "`Abstraktionsebene 1"' wurde ein Überblick über die für die Applikation verwendeten Pakete gegeben. 
Dieses Kapitel beschreibt die Pakete \texttt{Core}, \texttt{PawnCompilerLib} und \texttt{UsbDevicesLib}. Zusätzlich wird vorgestellt, wie die Pakete \texttt{AvalonDock}, \texttt{AvalonEdit} und \texttt{InplaceEditBoxLib} in die Applikation eingebunden wurden. Diese basieren auf frei zugänglichem Quellcode von Dritten.

In Abschnitt \ref{sec:EntwurfUI} wurde ein Mockup der Benutzeroberfläche entworfen, an dem sich sich die tatsächlich realisierte GUI orientiert. 
Sie besteht aus einem Hauptfenster, in das ein Texteditor, eine Geräteliste, eine Konsole und ein Projektexplorer eingebettet werden können. 
In der Beschreibung des \texttt{Core}-Paketes wird deshalb für jedes dieser Fensterelemente erklärt, wie sie Benutzeroberfläche ("`View"') und die zugehörige Programmlogik ("`ViewModel"') erstellt wurden. 

\section{\texttt{Core}-Paket}

\subsection{Erstellung des Hauptfensters}

\subsubsection{View}

Die View des Hauptfensters besteht aus einer horizontalen Menüleiste als oberstes Element, einer Symbolleiste sowie freier Fläche, in die andere Fensterelemente eingebettet werden können. Das Hauptfenster ist in einer XAML-Datei mit dem Namen "`MainWindow"' definiert.

Zur Erstellung der Menüleiste wird eine Instanz der Klasse \texttt{Menu} erzeugt, die sich im Namespace \texttt{Systems.Windows.Controls} befindet. Menüeinträge können innerhalb eines \texttt{Menu}-Objektes mit Objekten der Klasse \texttt{MenuItem} erstellt werden. Durch Schachtelung von \texttt{MenuItem}-Objekten ineinander kann sehr einfach ein Menü mit ineinander geschachtelten Inhalten erstellt werden.   
Sobald ein Mausklick auf das Element registriert wird, kann \texttt{MenuItem} einen Command auslösen. 
Die Klasse stellt dazu die Property \texttt{Command} bereit, die über Data Binding an eine Property vom Typ \texttt{ICommand} eines ViewModels gebunden wird. Das Prinzip von Commands und Data Binding in WPF-Applikationen wurde in Abschnitt \ref{sec:MVVM} "`MVVM-Pattern"' näher erläutert. Das folgende Codebeispiel in XAML erstellt eine Menüleiste mit geschachtelten Menüeinträgen.
(Evtl. Bild des erzeugten Menüs einfügen)  

	
\begin{minted}[breaklines, linenos]{xml}
<Menu IsMainMenu="True" >
	<MenuItem Header="_Code" >
		<MenuItem Header="Compile" Command="{Binding OnCompileActiveDocumentCommand}"/>
		<MenuItem Header="Flash" Command="{Binding OnFlashActiveDocumentCommand}"/>
	</MenuItem>
</Menu>
\end{minted}

Um Symbolleisten zu erstellen, stellt das .NET-Framework die Klasse \texttt{Toolbar} bereit. 
Innerhalb der Symbolleiste wird die Klasse \texttt{Button} benutzt, um Schaltflächen zu kreieren. Objekte vom Typ \texttt{Button} können Commands auslösen, sobald ein Mausklick auf das Objekt registriert wird.
Innerhalb der \texttt{Button}-Objekte werden Objekte der Klasse \texttt{Image} erstellt, über deren Property \texttt{Source} der Pfad zu einer Bilddatei angegeben wird.
Die verwendeten Symbole stammen von der "`Visual Studio Image Library"', die von Microsoft frei zur Verfügung gestellt wird \cite{VSImgLib}.

Innerhalb der verbleibenden leeren Fläche sollen andere Elemente eingebettet werden können. Hierzu wird \emph{AvalonDock} verwendet. Das Paket ermöglicht es, Fensterelemente an den Rändern eines Hauptfensters anzudocken, frei herauszulösen oder auszublenden. Mithilfe der \texttt{DockingManager}-Klasse können die Fensterelemente in das Hauptfenster eingebettet werden. In \emph{AvalonDock} gibt es zwei verschiedene Typen von Rahmenfenstern, in die selbst jeweils mehrere Fenster eingebettet können. \\
Der erste Typ von Rahmenfenster ist \texttt{LayoutDocumentPane} und kann Fenster vom Typ \texttt{LayoutDocument} aufnehmen.
Es kann nicht an Ränder angedockt werden.
\texttt{LayoutDocument}-Elemente werden im Rahmenfenster als Tab dargestellt und sind prädestiniert dafür, Textdokumente anzuzeigen. \\
Der zweite Typ von Rahmenfenster ist \texttt{LayoutAnchorablePane} und kann Fenster vom Typ \texttt{LayoutAnchorable} aufnehmen.
Dieser Typ kann an Ränder angedockt oder am Rand versteckt werden. \\
Beide Fenstertypen können aus ihrem Rahmenfenster herausgelöst und als frei verschiebbares \texttt{LayoutFloatingWindow} dargestellt werden.

Abbildung \ref{fig:Fenstertypen} zeigt die Benutzeroberfläche des configurAIDERs. Die Rahmenfenster vom Typ \texttt{LayoutAnchorablePane} sind rot markiert. Das am linken Fensterrand angedockte \texttt{LayoutAnchorablePane} enthält zwei \texttt{LayoutAnchorable}-Fenster, den Projektexplorer und die Geräteliste. Über die schwarz markierten Tabs kann angewählt werden, welches \texttt{LayoutAnchorable} angezeigt werden soll.
Das am unteren Fensterrand angedockte \texttt{LayoutAnchorablePane} enthält ein \texttt{LayoutAnchorable}, die Konsole. \\
Das grün markierte Rahmenfenster ist vom Typ \texttt{LayoutDocumentPane}. Es enthält zwei \texttt{LayoutDocument}-Fenster, in denen ein im Texteditor geöffnetes Dokument angezeigt werden kann. Über die hellblau markierten Tabs kann angewählt werden, welches der beiden Dokumente angezeigt wird.


\begin{figure}[!htbp]
	\centering
		\includegraphics[width=\textwidth]{images/configurAIDERFenstertypen.png}
	\caption{Mockup der Benutzeroberfläche des configurAIDERs}
	\label{fig:Fenstertypen}
\end{figure}


Die Klasse \texttt{DockingManager} besitzt die Properties \texttt{DocumentsSource} und \texttt{AnchorablesSource}, an die jeweils eine Property vom Typ \texttt{IEnumerable} gebunden werden kann. 
In \texttt{IEnumerable} enthaltene Objekte, die an \texttt{DocumentsSource} gebunden sind, werden als Fenster vom Typ \texttt{LayoutDocument} dargestellt. 
Analog dazu werden in \texttt{IEnumerable} enthaltene Objekte, die an \texttt{AnchorablesSource} gebunden sind, als Fenster vom Typ \texttt{LayoutAnchorable} dargestellt. \\
An \texttt{DocumentsSource} wird die Property \texttt{Documents} von \texttt{MainViewModel} gebunden, die vom Typ \texttt{ObservableCollection<DocumentViewModel>} ist.
\\
An \texttt{AnchorablesSource} wird die Property \texttt{Anchorables} von \texttt{MainViewModel} gebunden, die vom Typ \texttt{IEnumerable<IAnchorable>} ist. 

Über die Properties \texttt{DocumentsSource} und \texttt{AnchorablesSource} wird allerdings nur festgelegt, welche Daten dargestellt werden sollen, nicht aber wie diese Daten visualisiert werden sollen.
Für die darzustellenden Elemente Texteditor, Projektexplorer, Konsole und Geräteliste muss deshalb Darstellung und Aussehen der zugehörigen Daten definiert werden. Für diese Elemente wurde deshalb jeweils eine eigene View erstellt, die im späteren Verlauf der Arbeit noch beschrieben werden. 
Die Views wurden als \texttt{DataTemplate} erstellt. Mit \texttt{DataTemplates} lassen sich Vorlagen definieren, die die visuelle Präsentation von Daten beschreiben.  \\
Die Klasse \texttt{PanesTemplateSelector} stellt die \texttt{DataTemplate}-Objekte zur Verfügung. Um \emph{AvalonDock} das Aussehen der darzustellenden Daten mitzuteilen, muss eine Instanz von \texttt{PanesTemplateSelector} der \texttt{LayoutItemTemplateSelector}-Property von \texttt{DockingManager} zugewiesen werden. 

LayoutItemContainerStyle von DockMAnager beschrieben

PanesTemplateSelector / LayoutItemTemplateSelector setzt den DataContext der Views auf das zugehörige ViewModel

LayoutPanel beschreiben, Layout beim Starten wird aus XML-Datei serialisiert, deserialisierung bei Schließen des Programms. 


\subsubsection{ViewModel}

\texttt{MainViewModel} ist das ViewModel, mit der die View des Hauptfensters \texttt{MainWindow} über Data Binding und Commands gekoppelt ist. Es stellt Logik und Daten für \texttt{MainWindow} bereit, wie z.B. Objekte von ViewModel-Klassen, die die Inhalte der \emph{AvalonDock}-Elemente definieren. 

Die Property \texttt{Documents} stellt eine \texttt{ObservableCollection} bereit, in der sich Objekte vom Typ \texttt{DocumentViewModel} befinden. Diese Objekte repräsentieren Textdokumente, die in einem \emph{AvalonDock}-Fenster vom Typ \texttt{DocumentLayout} dargestellt werden. \texttt{DocumentViewModel} wird im Abschnitt \ref{sec:Texteditor} Texteditor näher beschrieben.
Die Klasse \texttt{ObservableCollection} ist eine generische Collection, die die Interfaces \texttt{INotifyCollectionChanged} und \texttt{INotifyPropertyChanged} implementiert, die für den Benachrichtigungsmechanismus von ViewModel zu View benötigt werden (siehe Abschnitt \ref{sec:MVVM}, "`MVVM-Pattern"').



Die Property \texttt{Anchorables} stellt eine generische Auflistung vom Typ \texttt{IEnumberable} zur Verfügung, in der sich Objekte vom Typ \texttt{IAnchorable} befinden. 
Im Gegensatz zu \texttt{Documents} wird hier keine \texttt{ObservableCollection} benötigt, da die Anzahl der \texttt{LayoutAnchorable}-Fenster während der Laufzeit der Applikation stets gleich ist und somit kein Benachrichtigungsmechanismus über hinzugefügte oder gelöschte Objekte benötigt wird. 
Das Interface \texttt{IAnchorable} wird von allen ViewModels implementiert, deren zugehörige View in \texttt{LayoutAnchorable}-Elementen dargestellt werden. Dies sind die ViewModels \texttt{ProjectExplorerContainerViewModel}, \texttt{ConsoleViewModel} und \texttt{DeviceListViewModel}. Sie repräsentieren in dieser Reihenfolge den Projektexplorer, die Konsole sowie die Geräteliste.







Außerdem wird in \texttt{MainViewModel} die Logik zu folgenden Steuerelementen des Menüs und der Toolbar festgelegt: 

\begin{itemize}
	\item \textsc{Save}: Speichert die im Texteditor angezeigte Pawn-Datei auf dem Dateipfad, auf dem das Dokument aktuell gespeichert ist.
	\item \textsc{Save as}: Speichert die im Texteditor angezeigte Pawn-Datei auf einem Dateipfad, den der Benutzer in einem sich öffnenden Dialogfeldes angeben kann.
	\item \textsc{Open}: Öffnet eine Pawn-Datei von einem Dateipfad, den der Benutzer in einem sich öffnenden Dialogfeldes angeben kann.
	\item \textsc{Compile}: Kompiliert die im Texteditor angezeigte Pawn-Datei mit dem Pawn-Comiler 
	\item \textsc{Flash}: Kompiliert die im Texteditor angezeigte Pawn-Datei und übertragt die erzeugte Hex-Datei auf den Flash-Speicher einer über USB mit dem PC verbundenen GIGABOX FD
\end{itemize}

Die Kopplung zwischen den Steuerelementen der View und der zugehörigen Logik im ViewModel geschieht über Commands. 
Die \texttt{Command}-Property eines Steuerelementes der View wird dabei an eine Property vom Typ \texttt{ICommand} des ViewModels gebunden.
Ein Klick auf eines dieser Steuerelemente ruft die darauf gebundene \texttt{ICommand}-Property des ViewModels auf, worauf die dort implementierte Logik ausgeführt wird. Klickt der Benutzer beispielsweise auf den Button \textsc{Save} der Toolbar, wird die Property \texttt{OnSaveFileCommand} aufgerufen. Die dort implementierte Logik speichert das im Texteditor angezeigte Dokument auf dem aktuellen Dateipfad des Dokuments.
 


\subsection{Erstellung des Texteditors}	\label{sec:Texteditor}

Es wurde der in Abschnitt \ref{sec:Abstraktionsebene1} erwähnte Texteditor \emph{AvalonEdit} in der Version 4.3.0 verwendet. 
An dieser Stelle wird nicht näher auf den Quellcode von \emph{AvalonEdit} eingegangen, sondern beschrieben, wie der Editor in die Applikation integriert wurde.

\emph{AvalonEdit} stellt als Schnittstelle nach außen die Klasse \texttt{TextEditor} bereit, mit deren Hilfe der Texteditor in eine Applikation eingebettet werden kann.
Die Einbindung von \texttt{TextEditor} erfolgt in der View \texttt{MainWindow} über die Property \texttt{LayoutItemTemplateSelector} der \texttt{DockingManager}-Klasse von \emph{AvalonDock}. Der von \emph{AvalonEdit} erzeugte Inhalt wird in einem \emph{AvalonDock}-Fenster vom Typ \texttt{LayoutDocument} dargestellt.
 
Über Properties von \texttt{TextEditor} kann der angezeigte Text festgelegt sowie Einstellungen zu Aussehen und Verhalten des Texteditors gemacht werden. 
Die benötigten Properties wurden in \texttt{MainWindow} mithilfe von Data Binding an Properties der Klasse \texttt{DocumentViewModel} gebunden. 
In \texttt{DocumentViewModel} können somit Einstellungen von \emph{AvalonEdit} gesetzt werden.
Dabei repräsentiert jedes Objekt von \texttt{DocumentViewModel} ein \emph{AvalonDock}-Element vom Typ \texttt{LayoutDocument}.

Die folgende Aufzählung zeigt, welche Eigenschaften des Texteditors in \texttt{DocumentViewModel} vorgenommen werden können:

\begin{itemize}
	\item Festlegung des angezeigten Textes.
	\item Festlegung der Schriftgröße.
	\item Festlegung der Schriftart.
	\item Festlegung von Syntax-Highlighting. Für gängige Programmiersprachen bestehen vordefinierte Regeln des Syntax-Highlightings oder es können eigene Regeln in einer XML-Datei definiert werden.
	\item Anzeige von Zeilennummern ein- oder ausschalten.
	\item Abfrage, ob angezeigtes Dokument modifiziert wurde und sich von der ursprünglich geöffneten Version unterscheidet.
	
\end{itemize}

\texttt{DocumentViewModel} enthält außerdem Funktionen, die das Öffnen von Dokumenten im Texteditor ermöglichen. Mit \emph{OpenDocumentFromPath()} kann ein Dokument von einem beliebigen Dateipfad geöffnet werden, die Funktion erwartet den Pfad als Argument.
Mit \emph{OpenDocumentFromProjectExplorer()} kann ein Textdokument vom Projektexplorer aus geöffnet werden, indem ein Objekt vom Typ \texttt{IProjectExplorerItem} als Argument übergeben wird.

Die Funktion \emph{Update()} dient dem Zweck, Daten im Texteditor zu aktualisieren, die im Projektexplorer geändert wurden.  
Als Beispiel sei hier ein Projekt angeführt, in dem ein Textdokument angelegt wurde. Wird nun der Name des Projektes geändert, ändert sich gleichzeitig der Dateipfad des Textdokumentes, da dieses sich in einem Unterverzeichnis des Projektverzeichnisses befindet. Folglich muss das Objekt von \texttt{DocumentViewModel}, das das Textdokument repräsentiert, über die Änderung des Projektnamens informiert werden und der dort hinterlegte Dateipfad des Textdokumentes aktualisiert werden. Würde der Pfad nicht aktualisiert werden, würde ein Speichern des Dokumentes fehlschlagen, da der in \texttt{DocumentViewModel} hinterlegte Dateipfad nicht mehr existiert.
Dieser Aktualisierungsmechanismus wurde nach dem Prinzip des Observer-Patterns implementiert.






\subsection{Erstellung des Projektexplorers}



Realisierung mit TreeView

Beschreibung der Funktionen

\subsection{Erstellung der Konsole}

\subsubsection{View}

Die View der Konsole ist in der XAML-Datei \texttt{ConsoleView} definiert. Die von \texttt{ConsoleView} erzeugten grafischen Elemente wird in einem \emph{AvalonDock}-Fenster vom Typ \texttt{LayoutAnchorable} dargestellt.

Die Konsole besteht aus einer Eingabezeile, die als oberstes Fensterelement angeordnet ist, sowie aus einem scrollbaren Ausgabefeld.
Die Ausgabemeldungen sollen untereinander angeordnet werden, wobei die neueste Meldung das unterste Textelement im Ausgabefeld sein soll.


Das Eingabefeld wird mithilfe der Klasse \texttt{TextBox} erstellt. Der eingegebene Text wird die \texttt{Text}-Property von \texttt{TextBox} mit Data Binding an die Property \texttt{ConsoleInput} gebunden, die in \texttt{ConsoleViewModel} implementiert ist. Der im View eingegebene Text ist damit auch im ViewModel verfügbar.\\
Eine Texteingabe kann mit der Enter-Taste bestätigt werden, so wie es Anwender von Konsolenanwendungen gewöhnt sind.
Um dieses Verhalten zu erreichen, wird in der Property \texttt{InputBindings} von \texttt{TextBox} ein \texttt{KeyBinding} definiert. 
Dort wird ein Command definiert, der auf die Property \texttt{OnEnterPressedCommand} von \texttt{ConsoleViewModel} gebunden ist und bei Drücken der Enter-Taste ausgelöst wird.

Das Ausgabefeld könnte auf zwei verschiedene Arten realisiert werden.\\
Erstens könnte es als großes Textfeld realisiert werden, in dem jede neue Textausgabe in einer neuen Zeile unter der letzten Ausgabe hinzugefügt wird. \\
Zweitens könnte für jede Textausgabe ein eigenes Textfeld erstellt werden, die einzelnen Textfelder werden dann übereinander gestapelt dargestellt.

Die Implementierung der View wäre für die erste Lösung sehr einfach. Es muss ein Objekt der Klasse \texttt{TextBox} definiert werden und an eine \texttt{string}-Property im ViewModel gebunden werden. 
Allerdings muss im ViewModel ein Algorithmus implementiert werden, der dafür sorgt, dass neue Textausgaben stets in einer neuen Zeile dargestellt werden. \\
Es wurde die zweite Lösung umgesetzt, da dabei im ViewModel auf diesen Algorithmus verzichtet werden kann. Die Implementierung der View ist bei dieser Lösung dagegen komplexer und wird im Folgenden beschrieben.

Das Ausgabefeld wird bei dieser Lösung mithilfe der Klasse \texttt{ItemsControl} erstellt, die über die \texttt{ItemsSource}-Property an die Property \texttt{ConsoleOutput} vom Typ \texttt{ObservableCollection<string>} gebunden wird. 
\texttt{ItemsControl} wird innerhalb eines \texttt{ScrollViewer}-Objektes erstellt, dadurch werden die in \texttt{ConsoleOutput} enthaltenen Objekte auf einer scrollbaren Fläche dargestellt.
\texttt{ItemsControl} muss allerdings wissen, wie die Objekte aus \texttt{ConsoleOutput} visuell dargestellt werden sollen. Dazu muss ein \texttt{DataTemplate} definiert werden. Ein \texttt{DataTemplate} ist eine Vorlage, die festlegt, wie ein Objekt präsentiert werden soll.

Innerhalb des \texttt{DataTemplate} wird ein \texttt{TextBox}-Objekt erstellt, deren Property \texttt{Text} auf die \texttt{string}-Elemente in \texttt{ConsoleOutput} binden. 
Jeder \texttt{string} in \texttt{ConsoleOutput} wird somit von einem eigenen \texttt{TextBox}-Objekt als Text ausgegeben. 
Standardmäßig besitzt jede \texttt{TextBox} eine schwarze Umrahmung. 
Indem die Property \texttt{BorderThickness} von \texttt{TextBox} auf "`0"' gesetzt wird, wird dieser Rahmen ausgeblendet. Die Textausgaben erscheinen somit auf einer gemeinsamen Ausgabefläche und sind nicht voneinander abgetrennt.


\subsubsection{ViewModel}

Die View \texttt{ConsoleView} der Konsole ist mit dem ViewModel \texttt{ConsoleViewModel} nach dem MVVM-Pattern gekoppelt. \texttt{ConsoleViewModel} leitet von \texttt{ViewModelBase} ab (siehe Klassendiagramm in Abbildung \ref{fig:ClassDiagramViewModels}) und implementiert das Interface \texttt{IAnchorable}, da \texttt{ConsoleView} in einem \texttt{LayoutAnchorable}-Fenster dargestellt wird.
\texttt{ConsoleViewModel} stellt verschiedene Properties bereit, an die sich die View bindet. Die wichtigsten Properties sind hier \texttt{ConsoleOutput} vom Typ \texttt{ObservableCollection} und \texttt{ConsoleInput} vom Typ \texttt{string}. \texttt{ConsoleOutput} stellt der View die \texttt{string}-Elemente zur Verfügung, die im Ausgabefeld der Konsole angezeigt werden.
\texttt{ConsoleInput} enthält alle Zeichen, die aktuell im Eingabefeld der Konsole angezeigt werden.

Die Funktion \emph{WriteOutput()} schreibt einen als Argument übergebenen \texttt{string} in das Ausgabefeld der Konsole. Die Funktion ist mit dem Zugriffsmodifizierer \textsc{public} deklariert und ist damit die einzige Funktion, auf die von außerhalb der Klasse zugegriffen werden kann. Sie kann deshalb dazu benutzt werden, von anderen Klassen aus Text auf der Konsole auszugeben. \emph{WriteOutput()} wird beispielsweise benutzt, um das vom Pawn-Compiler erzeugten Protokoll (Log) auf der Konsole auszugeben.

Sobald der Benutzer eine Konsoleneingabe mit Enter bestätigt, wird \texttt{OnEnterPressedCommand} vom Typ \texttt{ICommand} aufgerufen. Dort wird die Funktion \emph{WriteOutput()} aufgerufen, die den vom Benutzer eingegebenen Textbefehl in das Ausgabefeld schreibt. Anschließend wird die Funktion \emph{ExecuteInput()} aufgerufen, die den Befehl an eine per USB verbundene und in der Geräteliste als Zielgerät markierte GIGABOX FD sendet. Dabei wird die Klasse \texttt{GigaboxFDCommunication} verwendet, die in Abschnitt \ref{sec:GIGABOXKommunikation} "`Kommunikation mit GIGABOX"' näher beschrieben wird. 

\subsection{Erstellung der Geräteliste}

\subsubsection{View}

\subsubsection{ViewModel}



\section{\texttt{UsbDevicesLib}-Paket} \label{sec:GIGABOXKommunikation}

Mit dieser Klasse wird UseCase "`Kommunikation mit einer GIGABOX"'
realisiert.

Beschreibung der API zu GIGABOX

\section{\texttt{PawnCompilerLib}-Paket}